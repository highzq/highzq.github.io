<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Gao">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Gao">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>问题整理 · GaoBlog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Gao Blog</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">问题整理</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Gao Blog</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            问题整理
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "文章">文章</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">17,411</span>阅读时长: <span class="post-count reading-time">67 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/07/13</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h3 id="介绍一下js的数据类型有哪些-值是如何存储的"><a href="#介绍一下js的数据类型有哪些-值是如何存储的" class="headerlink" title="介绍一下js的数据类型有哪些,值是如何存储的"></a>介绍一下js的数据类型有哪些,值是如何存储的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一共有8种数据类型，7种基本数据类型</span><br><span class="line">String </span><br><span class="line">Number </span><br><span class="line">Boolean </span><br><span class="line">Null </span><br><span class="line">Undefined </span><br><span class="line">Symbol（es6 新增类型，表示第一无二的值） </span><br><span class="line">BigInt（es10 新增数据类型，目的是比Number数据类型支持的范围更大的整数值）</span><br><span class="line">Object（1种引用数据类型，里面包含 function、Array、Date等，JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一）</span><br><span class="line"></span><br><span class="line">原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class="line"></span><br><span class="line">引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br></pre></td></tr></table></figure>
<h3 id="amp-amp-、-和-运算符分别能做什么"><a href="#amp-amp-、-和-运算符分别能做什么" class="headerlink" title="&amp;&amp; 、 ||和!! 运算符分别能做什么"></a>&amp;&amp; 、 ||和!! 运算符分别能做什么</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;&amp; 并且符，使用时两边的值结果都必须为true才返回true</span><br><span class="line">|| 或者符，两边的值结果有一个为true最终判断结果就位true</span><br><span class="line">!! 可以强制把右边的值转为布尔类型的值（两个感叹号正好就是单纯转换成布尔类型的方式）</span><br></pre></td></tr></table></figure>
<h3 id="JS的数据类型的转换"><a href="#JS的数据类型的转换" class="headerlink" title="JS的数据类型的转换"></a>JS的数据类型的转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 JS 中类型转换只有三种情况，分别是：</span><br><span class="line"></span><br><span class="line">- 转换为布尔值（调用Boolean()方法）</span><br><span class="line">- 转换为数字（调用Number()、parseInt()和parseFloat()方法）</span><br><span class="line">- 转换为字符串（调用.toString()或者String()方法）</span><br><span class="line"></span><br><span class="line">null和underfined没有.toString方法</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<h3 id="JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call"><a href="#JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call" class="headerlink" title="JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()"></a>JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()</h3><blockquote>
<p>（1）typeof<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof 对于原始类型来说，除了 null 都可以显示正确的类型</span><br><span class="line"></span><br><span class="line">console.log(typeof 2);               // number</span><br><span class="line">console.log(typeof true);            // boolean</span><br><span class="line">console.log(typeof &apos;str&apos;);           // string</span><br><span class="line">console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object</span><br><span class="line">console.log(typeof function()&#123;&#125;);    // function</span><br><span class="line">console.log(typeof &#123;&#125;);              // object</span><br><span class="line">console.log(typeof undefined);       // undefined</span><br><span class="line">console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object</span><br><span class="line"></span><br><span class="line">typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>（2）instanceof<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//重点</span><br><span class="line">instanceof 可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断</span><br><span class="line">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class="line">其意思就是判断对象是否是某一数据类型（如Array）的实例</span><br><span class="line"></span><br><span class="line">console.log(2 instanceof Number);                    // false</span><br><span class="line">console.log(true instanceof Boolean);                // false </span><br><span class="line">console.log(&apos;str&apos; instanceof String);                // false  </span><br><span class="line">console.log([] instanceof Array);                    // true</span><br><span class="line">console.log(function()&#123;&#125; instanceof Function);       // true</span><br><span class="line">console.log(&#123;&#125; instanceof Object);                   // true    </span><br><span class="line">// console.log(undefined instanceof Undefined);      //报错</span><br><span class="line">// console.log(null instanceof Null);                //报错</span><br><span class="line">复制代码可以看出直接的字面量值判断数据类型，instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。</span><br><span class="line">我们来看一下 instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断一个对象是否是数据类型的实例。在这里字面量值，2， true ，&apos;str&apos;不是实例，所以判断值为false。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>（3）constructor<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log((2).constructor === Number); // true</span><br><span class="line">console.log((true).constructor === Boolean); // true</span><br><span class="line">console.log((&apos;str&apos;).constructor === String); // true</span><br><span class="line">console.log(([]).constructor === Array); // true</span><br><span class="line">console.log((function() &#123;&#125;).constructor === Function); // true</span><br><span class="line">console.log((&#123;&#125;).constructor === Object); // true</span><br><span class="line"></span><br><span class="line">这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了</span><br><span class="line"></span><br><span class="line">function Fn()&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Fn.prototype=new Array();</span><br><span class="line"> </span><br><span class="line">var f=new Fn();</span><br><span class="line"> </span><br><span class="line">console.log(f.constructor===Fn);    // false</span><br><span class="line">console.log(f.constructor===Array); // true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>（4）Object.prototype.toString.call() 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = Object.prototype.toString;</span><br><span class="line"> </span><br><span class="line">console.log(a.call(2));</span><br><span class="line">console.log(a.call(true));</span><br><span class="line">console.log(a.call(&apos;str&apos;));</span><br><span class="line">console.log(a.call([]));</span><br><span class="line">console.log(a.call(function()&#123;&#125;));</span><br><span class="line">console.log(a.call(&#123;&#125;));</span><br><span class="line">console.log(a.call(undefined));</span><br><span class="line">console.log(a.call(null));</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="介绍-JS-有哪些内置对象？"><a href="#介绍-JS-有哪些内置对象？" class="headerlink" title="介绍 JS 有哪些内置对象？"></a>介绍 JS 有哪些内置对象？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在</span><br><span class="line">全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</span><br><span class="line"></span><br><span class="line">标准内置对象的分类</span><br><span class="line"></span><br><span class="line">（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</span><br><span class="line"></span><br><span class="line">例如 Infinity、NaN、undefined、null 字面量</span><br><span class="line"></span><br><span class="line">（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</span><br><span class="line"></span><br><span class="line">例如 eval()、parseFloat()、parseInt() 等</span><br><span class="line"></span><br><span class="line">（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</span><br><span class="line"></span><br><span class="line">例如 Object、Function、Boolean、Symbol、Error 等</span><br><span class="line"></span><br><span class="line">（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</span><br><span class="line"></span><br><span class="line">例如 Number、Math、Date</span><br><span class="line"></span><br><span class="line">（5）字符串，用来表示和操作字符串的对象。</span><br><span class="line"></span><br><span class="line">例如 String、RegExp</span><br><span class="line"></span><br><span class="line">（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</span><br><span class="line"></span><br><span class="line">（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</span><br><span class="line"></span><br><span class="line">例如 Map、Set、WeakMap、WeakSet</span><br><span class="line"></span><br><span class="line">（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</span><br><span class="line"></span><br><span class="line">例如 SIMD 等</span><br><span class="line"></span><br><span class="line">（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</span><br><span class="line"></span><br><span class="line">例如 JSON 等</span><br><span class="line"></span><br><span class="line">（10）控制抽象对象</span><br><span class="line"></span><br><span class="line">例如 Promise、Generator 等</span><br><span class="line"></span><br><span class="line">（11）反射</span><br><span class="line"></span><br><span class="line">例如 Reflect、Proxy</span><br><span class="line"></span><br><span class="line">（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</span><br><span class="line"></span><br><span class="line">例如 Intl、Intl.Collator 等</span><br><span class="line"></span><br><span class="line">（13）WebAssembly</span><br><span class="line"></span><br><span class="line">（14）其他</span><br><span class="line"></span><br><span class="line">例如 arguments</span><br></pre></td></tr></table></figure>
<h3 id="undefined-与-undeclared-的区别？"><a href="#undefined-与-undeclared-的区别？" class="headerlink" title="undefined 与 undeclared 的区别？"></a>undefined 与 undeclared 的区别？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已在作用域中声明但还没有赋值的变量，是 undefined。相反，还没有在作用域中声明过的变量，是 undeclared 的。</span><br><span class="line">对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ</span><br><span class="line">eof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。</span><br></pre></td></tr></table></figure>
<h3 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class="line">undefined 代表的含义是未定义，</span><br><span class="line">null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class="line">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class="line">/*</span><br><span class="line">    其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，</span><br><span class="line">    为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。</span><br><span class="line">    虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</span><br><span class="line">*/</span><br><span class="line">undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它</span><br><span class="line">会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</span><br><span class="line">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等</span><br><span class="line">号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br></pre></td></tr></table></figure>
<h3 id="和-的valueOf和toString的结果是什么？"><a href="#和-的valueOf和toString的结果是什么？" class="headerlink" title="{}和[]的valueOf和toString的结果是什么？"></a>{}和[]的valueOf和toString的结果是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Javascript-的作用域和作用域链？"><a href="#Javascript-的作用域和作用域链？" class="headerlink" title="Javascript 的作用域和作用域链？"></a>Javascript 的作用域和作用域链？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【作用域：】 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class="line">【作用域链：】 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</span><br></pre></td></tr></table></figure>
<h3 id="javascript-创建对象的几种方式？"><a href="#javascript-创建对象的几种方式？" class="headerlink" title="javascript 创建对象的几种方式？"></a>javascript 创建对象的几种方式？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class="line"></span><br><span class="line">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class="line"></span><br><span class="line">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class="line"></span><br><span class="line">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class="line"></span><br><span class="line">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class="line"></span><br><span class="line">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br></pre></td></tr></table></figure>
<h3 id="JavaScript-继承的几种实现方式？"><a href="#JavaScript-继承的几种实现方式？" class="headerlink" title="JavaScript 继承的几种实现方式？"></a>JavaScript 继承的几种实现方式？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</span><br><span class="line"></span><br><span class="line">（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</span><br><span class="line"></span><br><span class="line">（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</span><br><span class="line"></span><br><span class="line">（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</span><br><span class="line"></span><br><span class="line">（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</span><br><span class="line"></span><br><span class="line">（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</span><br></pre></td></tr></table></figure>
<h3 id="寄生式组合继承的实现？"><a href="#寄生式组合继承的实现？" class="headerlink" title="寄生式组合继承的实现？"></a>寄生式组合继承的实现？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person</span><br><span class="line">Student</span><br><span class="line"></span><br><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(123);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Student(name, grade)&#123;</span><br><span class="line">    Person.call(this,name);</span><br><span class="line">    this.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = Object.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.sayMyGrade = function() &#123;</span><br><span class="line">  console.log(&quot;My grade is &quot; + this.grade + &quot;.&quot;);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="谈谈你对this、call、apply和bind的理解"><a href="#谈谈你对this、call、apply和bind的理解" class="headerlink" title="谈谈你对this、call、apply和bind的理解"></a>谈谈你对this、call、apply和bind的理解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总结:</span><br><span class="line">1. 在浏览器里，在全局范围内this 指向window对象；</span><br><span class="line">2. 在函数中，this永远指向最后调用他的那个对象；</span><br><span class="line">3. 构造函数中，this指向new出来的那个新的对象；</span><br><span class="line">4. call、apply、bind中的this被强绑定在指定的那个对象上；</span><br><span class="line">5. 箭头函数中this比较特殊,箭头函数this为父作用域的this，不是调用时的this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的this指向是静态的,声明的时候就确定了下来；</span><br><span class="line">6. apply、call、bind都是js给函数内置的一些API，调用他们可以为函数指定this的执行,同时也可以传参。</span><br><span class="line"></span><br><span class="line">区别:</span><br><span class="line">- call/apply改变了函数的this上下文后马上执行该函数</span><br><span class="line">- bind则是返回改变了上下文后的函数,不执行该函数</span><br></pre></td></tr></table></figure>
<h3 id="JavaScript-原型，原型链？-有什么特点？"><a href="#JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="JavaScript 原型，原型链？ 有什么特点？"></a>JavaScript 原型，原型链？ 有什么特点？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prototype就是JS的原型，里面可以定义属性和方法</span><br><span class="line">当我们访问对象的一个属性时，对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。</span><br><span class="line">原型链的尽头一般来说都是 Object.prototype 所以这就 是我们新建的对象为什么能够使用 toString() 等方法的原因。</span><br></pre></td></tr></table></figure>
<h3 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p.proto</span><br><span class="line">p.constructor.prototype</span><br><span class="line">Object.getPrototypeOf(p)</span><br></pre></td></tr></table></figure>
<h3 id="什么是闭包，为什么要用它？"><a href="#什么是闭包，为什么要用它？" class="headerlink" title="什么是闭包，为什么要用它？"></a>什么是闭包，为什么要用它？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">闭包是指有权访问另一个函数作用域内变量的函数</span><br><span class="line">创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以 访问到当前函数的局部变量。</span><br><span class="line"></span><br><span class="line">闭包有两个常用的用途:</span><br><span class="line">- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class="line">- 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</span><br><span class="line"></span><br><span class="line">function a()&#123;</span><br><span class="line">    var n = 0;</span><br><span class="line">    function add()&#123;</span><br><span class="line">       n++;</span><br><span class="line">       console.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">    return add;</span><br><span class="line">&#125;</span><br><span class="line">var a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span><br><span class="line">a1();    //1</span><br><span class="line">a1();    //2  第二次调用n变量还在内存中</span><br><span class="line"></span><br><span class="line">其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</span><br></pre></td></tr></table></figure>
<h3 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOM  指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class="line"></span><br><span class="line">BOM  指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM</span><br><span class="line">的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）</span><br><span class="line">对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati</span><br><span class="line">on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对</span><br><span class="line">象的子对象。</span><br></pre></td></tr></table></figure>
<h3 id="三种事件模型是什么？"><a href="#三种事件模型是什么？" class="headerlink" title="三种事件模型是什么？"></a>三种事件模型是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOM0级模型： ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class="line">IE 事件模型： 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class="line">DOM2 级事件模型： 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br></pre></td></tr></table></figure>
<h3 id="事件委托是什么？"><a href="#事件委托是什么？" class="headerlink" title="事件委托是什么？"></a>事件委托是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到</span><br><span class="line">目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</span><br><span class="line">使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</span><br></pre></td></tr></table></figure>
<h3 id="什么是事件传播"><a href="#什么是事件传播" class="headerlink" title="什么是事件传播?"></a>什么是事件传播?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在“当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。</span><br><span class="line">事件传播有三个阶段：</span><br><span class="line">1. 捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class="line">2. 目标阶段–事件已达到目标元素。</span><br><span class="line">3. 冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br></pre></td></tr></table></figure>
<h3 id="什么是事件捕获？"><a href="#什么是事件捕获？" class="headerlink" title="什么是事件捕获？"></a>什么是事件捕获？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。window----&gt; document----&gt; html----&gt; body ----&gt;目标元素</span><br><span class="line"></span><br><span class="line">html:</span><br><span class="line">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">js:</span><br><span class="line">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class="line">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class="line">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class="line">    el = document.querySelector(el);</span><br><span class="line">  &#125;;</span><br><span class="line">  el.addEventListener(event, callback, isCapture);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class="line">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class="line">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class="line">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class="line"></span><br><span class="line">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;child&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;parent&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;grandparent&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;document&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;html&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;window&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印window，document，html，grandparent和parent，这就是事件捕获。</span><br></pre></td></tr></table></figure>
<h3 id="什么是事件冒泡？"><a href="#什么是事件冒泡？" class="headerlink" title="什么是事件冒泡？"></a>什么是事件冒泡？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事件冒泡刚好与事件捕获相反，当前元素----&gt;body ----&gt; html----&gt;document ----&gt;window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。</span><br><span class="line">假设有如下的 HTML 结构：</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;grandparent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">对应的JS代码：</span><br><span class="line">function addEvent(el, event, callback, isCapture = false) &#123;</span><br><span class="line">  if (!el || !event || !callback || typeof callback !== &apos;function&apos;) return;</span><br><span class="line">  if (typeof el === &apos;string&apos;) &#123;</span><br><span class="line">    el = document.querySelector(el);</span><br><span class="line">  &#125;;</span><br><span class="line">  el.addEventListener(event, callback, isCapture);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addEvent(document, &apos;DOMContentLoaded&apos;, () =&gt; &#123;</span><br><span class="line">  const child = document.querySelector(&apos;.child&apos;);</span><br><span class="line">  const parent = document.querySelector(&apos;.parent&apos;);</span><br><span class="line">  const grandparent = document.querySelector(&apos;.grandparent&apos;);</span><br><span class="line"></span><br><span class="line">  addEvent(child, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;child&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(parent, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;parent&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(grandparent, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;grandparent&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(document, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;document&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  addEvent(&apos;html&apos;, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;html&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  addEvent(window, &apos;click&apos;, function (e) &#123;</span><br><span class="line">    console.log(&apos;window&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">addEventListener方法具有第三个可选参数useCapture，其默认值为false，事件将在冒泡阶段中发生，如果为true，则事件将在捕获阶段中发生。如果单击child元素，它将分别在控制台上打印child，parent，grandparent，html，document和window，这就是事件冒泡。</span><br></pre></td></tr></table></figure>
<h3 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><p>（1）创建新节点<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createDocumentFragment()    //创建一个DOM片段</span><br><span class="line">createElement()   //创建一个具体的元素</span><br><span class="line">createTextNode()   //创建一个文本节点</span><br></pre></td></tr></table></figure></p>
<p>（2）添加、移除、替换、插入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendChild(node)</span><br><span class="line">removeChild(node)</span><br><span class="line">replaceChild(new,old)</span><br><span class="line">insertBefore(new,old)</span><br></pre></td></tr></table></figure></p>
<p>（3）查找<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getElementById();</span><br><span class="line">getElementsByName();</span><br><span class="line">getElementsByTagName();</span><br><span class="line">getElementsByClassName();</span><br><span class="line">querySelector();</span><br><span class="line">querySelectorAll();</span><br></pre></td></tr></table></figure></p>
<p>（4）属性操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getAttribute(key);</span><br><span class="line">setAttribute(key, value);</span><br><span class="line">hasAttribute(key);</span><br><span class="line">removeAttribute(key);</span><br></pre></td></tr></table></figure></p>
<h3 id="js数组和对象有哪些原生方法-列举一下"><a href="#js数组和对象有哪些原生方法-列举一下" class="headerlink" title="js数组和对象有哪些原生方法,列举一下"></a>js数组和对象有哪些原生方法,列举一下</h3><p><img src="https://user-gold-cdn.xitu.io/2020/7/2/1730ee989aa2b15f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/2/1727407aed442084?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<h3 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h3><h3 id="Ajax-是什么-如何创建一个-Ajax？"><a href="#Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="Ajax 是什么? 如何创建一个 Ajax？"></a>Ajax 是什么? 如何创建一个 Ajax？</h3><p>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。<br>创建步骤：<br><img src="https://user-gold-cdn.xitu.io/2020/6/2/17274125a4cf4d61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1：创建Ajax对象</span><br><span class="line">var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);    //兼容IE6及以下版本</span><br><span class="line">//2：配置 Ajax请求地址</span><br><span class="line">xhr.open(&apos;get&apos;,&apos;index.xml&apos;,true);</span><br><span class="line">//3：发送请求</span><br><span class="line">xhr.send(null); //严谨写法</span><br><span class="line">//4:监听请求，接受响应</span><br><span class="line">xhr.onreadysatechange = function()&#123;</span><br><span class="line">    if(xhr.readySates == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304)&#123;</span><br><span class="line">        console.log(xhr.responsetXML);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>promise封装实现<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// promise 封装实现：</span><br><span class="line"></span><br><span class="line">function getJSON(url) &#123;</span><br><span class="line">  // 创建一个 promise 对象</span><br><span class="line">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    // 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line"></span><br><span class="line">    // 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) return;</span><br><span class="line"></span><br><span class="line">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 设置错误监听函数</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 设置响应的数据类型</span><br><span class="line">    xhr.responseType = &quot;json&quot;;</span><br><span class="line"></span><br><span class="line">    // 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line"></span><br><span class="line">    // 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="js-延迟加载的方式有哪些？"><a href="#js-延迟加载的方式有哪些？" class="headerlink" title="js 延迟加载的方式有哪些？"></a>js 延迟加载的方式有哪些？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class="line">我了解到的几种方式是：</span><br><span class="line"></span><br><span class="line">将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class="line">给 js 脚本添加 defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class="line">给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class="line">动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br></pre></td></tr></table></figure>
<h3 id="谈谈你对模块化开发的理解？"><a href="#谈谈你对模块化开发的理解？" class="headerlink" title="谈谈你对模块化开发的理解？"></a>谈谈你对模块化开发的理解？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念</span><br><span class="line">，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</span><br><span class="line">由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污</span><br><span class="line">染，并且模块间没有联系。</span><br><span class="line">后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所</span><br><span class="line">有的所有的模块成员，外部代码可以修改内部属性的值。</span><br><span class="line">现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</span><br></pre></td></tr></table></figure>
<h3 id="js-的几种模块规范？"><a href="#js-的几种模块规范？" class="headerlink" title="js 的几种模块规范？"></a>js 的几种模块规范？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js 中现在比较成熟的有四种模块加载方案：</span><br><span class="line"></span><br><span class="line">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class="line">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class="line">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</span><br><span class="line">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</span><br></pre></td></tr></table></figure>
<h3 id="AMD和CMD-规范的区别？"><a href="#AMD和CMD-规范的区别？" class="headerlink" title="AMD和CMD 规范的区别？"></a>AMD和CMD 规范的区别？</h3><p>它们之间的主要区别有两个方面。</p>
<ol>
<li>第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</li>
<li>第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于<br> 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD<br> 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句<br> 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  var a = require(&quot;./a&quot;);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  // 此处略去 100 行</span><br><span class="line">  var b = require(&quot;./b&quot;); // 依赖可以就近书写</span><br><span class="line">  b.doSomething();</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// AMD 默认推荐</span><br><span class="line">define([&quot;./a&quot;, &quot;./b&quot;], function(a, b) &#123;</span><br><span class="line">  // 依赖必须一开始就写好</span><br><span class="line">  a.doSomething();</span><br><span class="line">  // 此处略去 100 行</span><br><span class="line">  b.doSomething();</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h3><ul>
<li>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>
<li>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
</ul>
<h3 id="requireJS的核心原理是什么？"><a href="#requireJS的核心原理是什么？" class="headerlink" title="requireJS的核心原理是什么？"></a>requireJS的核心原理是什么？</h3><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p>
<h3 id="谈谈JS的运行机制"><a href="#谈谈JS的运行机制" class="headerlink" title="谈谈JS的运行机制"></a>谈谈JS的运行机制</h3><ol>
<li><p>js单线程<br>JavaScript语言的一大特点就是单线程，即同一时间只能做一件事情。</p>
<blockquote>
<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
</blockquote>
</li>
<li><p>js事件循环<br>js代码执行过程中会有很多任务，这些任务总的分成两类：</p>
</li>
</ol>
<ul>
<li>同步任务</li>
<li>异步任务<br>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。，我们用导图来说明：<br><img src="https://user-gold-cdn.xitu.io/2020/6/2/172744a7fa2853c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></li>
</ul>
<p>回答：</p>
<ol>
<li>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</li>
<li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</li>
<li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</li>
<li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</li>
<li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li>
</ol>
<h3 id="arguments-的对象是什么？"><a href="#arguments-的对象是什么？" class="headerlink" title="arguments 的对象是什么？"></a>arguments 的对象是什么？</h3><p>arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map。<br>我们可以使用Array.prototype.slice将arguments对象转换成一个数组。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function one() &#123;</span><br><span class="line">  return Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意:箭头函数中没有arguments对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function one() &#123;</span><br><span class="line">  return arguments;</span><br><span class="line">&#125;</span><br><span class="line">const two = function () &#123;</span><br><span class="line">  return arguments;</span><br><span class="line">&#125;</span><br><span class="line">const three = function three() &#123;</span><br><span class="line">  return arguments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const four = () =&gt; arguments;</span><br><span class="line"></span><br><span class="line">four(); // Throws an error  - arguments is not defined</span><br></pre></td></tr></table></figure></p>
<h3 id="为什么在调用这个函数时，代码中的b会变成一个全局变量"><a href="#为什么在调用这个函数时，代码中的b会变成一个全局变量" class="headerlink" title="为什么在调用这个函数时，代码中的b会变成一个全局变量?"></a>为什么在调用这个函数时，代码中的b会变成一个全局变量?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunc() &#123;</span><br><span class="line">  let a = b = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure>
<p>原因是赋值运算符是从右到左的求值的。这意味着当多个赋值运算符出现在一个表达式中时，它们是从右向左求值的。所以上面代码变成了这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunc() &#123;</span><br><span class="line">  let a = (b = 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure></p>
<p>首先，表达式b = 0求值，在本例中b没有声明。因此，JS引擎在这个函数外创建了一个全局变量b，之后表达式b = 0的返回值为0，并赋给新的局部变量a。</p>
<p>我们可以通过在赋值之前先声明变量来解决这个问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunc() &#123;</span><br><span class="line">  let a,b;</span><br><span class="line">  a = b = 0;</span><br><span class="line">&#125;</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure></p>
<h3 id="简单介绍一下V8引擎的垃圾回收机制"><a href="#简单介绍一下V8引擎的垃圾回收机制" class="headerlink" title="简单介绍一下V8引擎的垃圾回收机制"></a>简单介绍一下V8引擎的垃圾回收机制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class="line"></span><br><span class="line">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class="line"></span><br><span class="line">新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class="line"></span><br><span class="line">（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</span><br><span class="line"></span><br><span class="line">（2）如果对象不存活，则释放对象的空间。</span><br><span class="line"></span><br><span class="line">（3）最后将 From 空间和 To 空间角色进行交换。</span><br><span class="line"></span><br><span class="line">新生代对象晋升到老生代有两个条件：</span><br><span class="line"></span><br><span class="line">（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</span><br><span class="line"></span><br><span class="line">（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</span><br><span class="line"></span><br><span class="line">老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class="line"></span><br><span class="line">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</span><br></pre></td></tr></table></figure>
<h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><ul>
<li>1.意外的全局变量</li>
<li>2.被遗忘的计时器或回调函数</li>
<li>3.脱离 DOM 的引用</li>
<li><p>4.闭包</p>
</li>
<li><p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p>
</li>
<li>第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li>第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
<h3 id="ECMAScript-是什么？"><a href="#ECMAScript-是什么？" class="headerlink" title="ECMAScript 是什么？"></a>ECMAScript 是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ECMAScript 是编写脚本语言的标准，这意味着JavaScript遵循ECMAScript标准中的规范变化，因为它是JavaScript的蓝图。</span><br><span class="line">ECMAScript 和 Javascript，本质上都跟一门语言有关，一个是语言本身的名字，一个是语言的约束条件</span><br><span class="line">只不过发明JavaScript的那个人（Netscape公司），把东西交给了ECMA（European Computer Manufacturers Association），这个人规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。</span><br><span class="line">javaScript = ECMAScript + DOM + BOM（自认为是一种广义的JavaScript）</span><br><span class="line">ECMAScript说什么JavaScript就得做什么！</span><br><span class="line">JavaScript（狭义的JavaScript）做什么都要问问ECMAScript我能不能这样干！如果不能我就错了！能我就是对的！</span><br><span class="line">——突然感觉JavaScript好没有尊严，为啥要搞个人出来约束自己，</span><br><span class="line">那个人被创造出来也好委屈，自己被创造出来完全是因为要约束JavaScript。</span><br></pre></td></tr></table></figure>
<h3 id="ECMAScript-2015（ES6）有哪些新特性？"><a href="#ECMAScript-2015（ES6）有哪些新特性？" class="headerlink" title="ECMAScript 2015（ES6）有哪些新特性？"></a>ECMAScript 2015（ES6）有哪些新特性？</h3><ul>
<li>块作用域</li>
<li>类</li>
<li>箭头函数</li>
<li>模板字符串</li>
<li>加强的对象字面</li>
<li>对象解构</li>
<li>Promise</li>
<li>模块</li>
<li>Symbol</li>
<li>代理（proxy）Set</li>
<li>函数默认参数</li>
<li>rest 和展开</li>
</ul>
<h3 id="var-let和const的区别是什么？"><a href="#var-let和const的区别是什么？" class="headerlink" title="var,let和const的区别是什么？"></a>var,let和const的区别是什么？</h3><p>var声明的变量会挂载在window上，而let和const声明的变量不会：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line">console.log(a,window.a);    // 100 100</span><br><span class="line"></span><br><span class="line">let b = 10;</span><br><span class="line">console.log(b,window.b);    // 10 undefined</span><br><span class="line"></span><br><span class="line">const c = 1;</span><br><span class="line">console.log(c,window.c);    // 1 undefined</span><br></pre></td></tr></table></figure></p>
<p>var声明变量存在变量提升，let和const不存在变量提升:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a); // undefined  ===&gt;  a已声明还没赋值，默认得到undefined值</span><br><span class="line">var a = 100;</span><br><span class="line"></span><br><span class="line">console.log(b); // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class="line">let b = 10;</span><br><span class="line"></span><br><span class="line">console.log(c); // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br><span class="line">const c = 10;</span><br></pre></td></tr></table></figure></p>
<p>let和const声明形成块作用域<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">if(1)&#123;</span><br><span class="line">  var a = 100;</span><br><span class="line">  let b = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a); // 100</span><br><span class="line">console.log(b)  // 报错：b is not defined  ===&gt; 找不到b这个变量</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">if(1)&#123;</span><br><span class="line">  var a = 100;</span><br><span class="line">  const c = 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 100</span><br><span class="line">console.log(c)  // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br></pre></td></tr></table></figure></p>
<p>同一作用域下let和const不能声明同名变量，而var可以<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line">console.log(a); // 100</span><br><span class="line"></span><br><span class="line">var a = 10;</span><br><span class="line">console.log(a); // 10</span><br><span class="line">-------------------------------------</span><br><span class="line">let a = 100;</span><br><span class="line">let a = 10;</span><br><span class="line"></span><br><span class="line">//  控制台报错：Identifier &apos;a&apos; has already been declared  ===&gt; 标识符a已经被声明了。</span><br></pre></td></tr></table></figure></p>
<p>暂存死区<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line"></span><br><span class="line">if(1)&#123;</span><br><span class="line">    a = 10;</span><br><span class="line">    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class="line">    // 而这时，还未到声明时候，所以控制台Error:a is not defined</span><br><span class="line">    let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>const<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">* &amp;emsp;&amp;emsp;1、一旦声明必须赋值,不能使用null占位。</span><br><span class="line">*</span><br><span class="line">* &amp;emsp;&amp;emsp;2、声明后不能再修改</span><br><span class="line">*</span><br><span class="line">* &amp;emsp;&amp;emsp;3、如果声明的是复合类型数据，可以修改其属性</span><br><span class="line">*</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">const a = 100; </span><br><span class="line"></span><br><span class="line">const list = [];</span><br><span class="line">list[0] = 10;</span><br><span class="line">console.log(list);&amp;emsp;&amp;emsp;// [10]</span><br><span class="line"></span><br><span class="line">const obj = &#123;a:100&#125;;</span><br><span class="line">obj.name = &apos;apple&apos;;</span><br><span class="line">obj.a = 10000;</span><br><span class="line">console.log(obj);&amp;emsp;&amp;emsp;// &#123;a:10000,name:&apos;apple&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="什么是箭头函数？"><a href="#什么是箭头函数？" class="headerlink" title="什么是箭头函数？"></a>什么是箭头函数？</h3><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">var getCurrentDate = function ()&#123;</span><br><span class="line">  return new Date();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">const getCurrentDate = () =&gt; new Date();</span><br></pre></td></tr></table></figure></p>
<p>在本例中，ES5 版本中有function(){}声明和return关键字，这两个关键字分别是创建函数和返回值所需要的。在箭头函数版本中，我们只需要()括号，不需要 return 语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有一个隐式的返回。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">function greet(name) &#123;</span><br><span class="line">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">const greet = (name) =&gt; `Hello $&#123;name&#125;`;</span><br><span class="line">const greet2 = name =&gt; `Hello $&#123;name&#125;`;</span><br></pre></td></tr></table></figure></p>
<p>我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getArgs = () =&gt; arguments</span><br><span class="line"></span><br><span class="line">const getArgs2 = (...rest) =&gt; rest</span><br></pre></td></tr></table></figure></p>
<p>箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">  result: 0,</span><br><span class="line">  nums: [1, 2, 3, 4, 5],</span><br><span class="line">  computeResult() &#123;</span><br><span class="line">    // 这里的“this”指的是“data”对象</span><br><span class="line">    const addAll = () =&gt; &#123;</span><br><span class="line">      return this.nums.reduce((total, cur) =&gt; total + cur, 0)</span><br><span class="line">    &#125;;</span><br><span class="line">    this.result = addAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。</p>
<h3 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a>什么是类？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。</span><br></pre></td></tr></table></figure>
<h3 id="什么是模板字符串？"><a href="#什么是模板字符串？" class="headerlink" title="什么是模板字符串？"></a>什么是模板字符串？</h3><p>模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">var greet = &apos;Hi I\&apos;m Mark&apos;;</span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">let greet = `Hi I&apos;m Mark`;</span><br></pre></td></tr></table></figure></p>
<p>在 ES5 中我们需要使用一些转义字符来达到多行的效果，在模板字符串不需要这么麻烦：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">var lastWords = &apos;\n&apos;</span><br><span class="line">  + &apos;   I  \n&apos;</span><br><span class="line">  + &apos;   Am  \n&apos;</span><br><span class="line">  + &apos;Iron Man \n&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">let lastWords = `</span><br><span class="line">    I</span><br><span class="line">    Am</span><br><span class="line">  Iron Man   </span><br><span class="line">`;</span><br></pre></td></tr></table></figure></p>
<p>在ES5版本中，我们需要添加\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//ES5 Version</span><br><span class="line">function greet(name) &#123;</span><br><span class="line">  return &apos;Hello &apos; + name + &apos;!&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//ES6 Version</span><br><span class="line">function greet(name) &#123;</span><br><span class="line">  return `Hello $&#123;name&#125; !`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用+运算符。在模板字符串s中，我们可以使用${expr}嵌入一个表达式，这使其比 ES5 版本更整洁。</p>
<h3 id="什么是对象解构？"><a href="#什么是对象解构？" class="headerlink" title="什么是对象解构？"></a>什么是对象解构？</h3><p>对象析构是从对象或数组中获取或提取值的一种新的、更简洁的方法。假设有如下的对象：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const employee = &#123;</span><br><span class="line">  firstName: &quot;Marko&quot;,</span><br><span class="line">  lastName: &quot;Polo&quot;,</span><br><span class="line">  position: &quot;Software Developer&quot;,</span><br><span class="line">  yearHired: 2017</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从对象获取属性，早期方法是创建一个与对象属性同名的变量。这种方法很麻烦，因为我们要为每个属性创建一个新变量。假设我们有一个大对象，它有很多属性和方法，用这种方法提取属性会很麻烦。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var firstName = employee.firstName;</span><br><span class="line">var lastName = employee.lastName;</span><br><span class="line">var position = employee.position;</span><br><span class="line">var yearHired = employee.yearHired;</span><br></pre></td></tr></table></figure></p>
<p>使用解构方式语法就变得简洁多了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; firstName, lastName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>
<p>我们还可以为属性取别名：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; firstName: fName, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>
<p>当然如果属性值为 undefined 时，我们还可以指定默认值，但是属性为null时指定的默认值则不生效：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; firstName = &quot;Mark&quot;, lastName: lName, position, yearHired &#125; = employee;</span><br></pre></td></tr></table></figure></p>
<h3 id="什么是Set对象，它是如何工作的？"><a href="#什么是Set对象，它是如何工作的？" class="headerlink" title="什么是Set对象，它是如何工作的？"></a>什么是Set对象，它是如何工作的？</h3><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<p>我们可以使用Set构造函数创建Set实例。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const set1 = new Set();</span><br><span class="line">const set2 = new Set([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;e&quot;]);</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的方式再次使用add。如果一个值已经存在于Set对象中，那么它将不再被添加。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set2.add(&quot;f&quot;);</span><br><span class="line">set2.add(&quot;g&quot;).add(&quot;h&quot;).add(&quot;i&quot;).add(&quot;j&quot;).add(&quot;k&quot;).add(&quot;k&quot;);</span><br><span class="line">// 后一个“k”不会被添加到set对象中，因为它已经存在了</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用has方法检查Set实例中是否存在特定的值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set2.has(&quot;a&quot;) // true</span><br><span class="line">set2.has(&quot;z&quot;) // true</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用size属性获得Set实例的长度。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set2.size // returns 10</span><br></pre></td></tr></table></figure></p>
<p>可以使用clear方法删除 Set 中的数据。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set2.clear();</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用Set对象来删除数组中重复的元素。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];</span><br><span class="line">const uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]</span><br></pre></td></tr></table></figure></p>
<p>另外还有WeakSet， 与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet对该对象的引用。</p>
<ul>
<li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>
<li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>
</ul>
<h3 id="什么是Proxy？"><a href="#什么是Proxy？" class="headerlink" title="什么是Proxy？"></a>什么是Proxy？</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<h3 id="写一个通用的事件侦听器函数？"><a href="#写一个通用的事件侦听器函数？" class="headerlink" title="写一个通用的事件侦听器函数？"></a>写一个通用的事件侦听器函数？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EventUtils = &#123;</span><br><span class="line">  // 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br><span class="line">  // 添加事件</span><br><span class="line">  addEvent: function(element, type, handler) &#123;</span><br><span class="line">    if (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, false);</span><br><span class="line">    &#125; else if (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(&quot;on&quot; + type, handler);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      element[&quot;on&quot; + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 移除事件</span><br><span class="line">  removeEvent: function(element, type, handler) &#123;</span><br><span class="line">    if (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, false);</span><br><span class="line">    &#125; else if (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(&quot;on&quot; + type, handler);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      element[&quot;on&quot; + type] = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 获取事件目标</span><br><span class="line">  getTarget: function(event) &#123;</span><br><span class="line">    return event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span><br><span class="line">  getEvent: function(event) &#123;</span><br><span class="line">    return event || window.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span><br><span class="line">  stopPropagation: function(event) &#123;</span><br><span class="line">    if (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      event.cancelBubble = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 取消事件的默认行为</span><br><span class="line">  preventDefault: function(event) &#123;</span><br><span class="line">    if (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      event.returnValue = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？"><a href="#什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？" class="headerlink" title="什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？"></a>什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。</span><br><span class="line">函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。</span><br><span class="line">函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试 - 但如果不熟悉它以及与之相关的常见模式，函数式的代码也可能看起来更密集杂乱，并且 相关文献对新人来说是不好理解的。</span><br></pre></td></tr></table></figure>
<h3 id="什么是高阶函数？"><a href="#什么是高阶函数？" class="headerlink" title="什么是高阶函数？"></a>什么是高阶函数？</h3><p>高阶函数只是将函数作为参数或返回值的函数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function higherOrderFunction(param,callback)&#123;</span><br><span class="line">    return callback(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="为什么函数被称为一等公民？"><a href="#为什么函数被称为一等公民？" class="headerlink" title="为什么函数被称为一等公民？"></a>为什么函数被称为一等公民？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:</span><br><span class="line"></span><br><span class="line">赋值（var func = function()&#123;&#125;）、</span><br><span class="line">传参(function func(x,callback)&#123;callback();&#125;)、</span><br><span class="line">返回(function()&#123;return function()&#123;&#125;&#125;)，</span><br><span class="line"></span><br><span class="line">这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)。这样的多重身份让JavaScript的函数变得非常重要。</span><br></pre></td></tr></table></figure>
<h3 id="手动实现Array-prototype-map-方法"><a href="#手动实现Array-prototype-map-方法" class="headerlink" title="手动实现Array.prototype.map 方法"></a>手动实现Array.prototype.map 方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</span><br><span class="line">function map(arr, mapCallback) &#123;</span><br><span class="line">  // 首先，检查传递的参数是否正确。</span><br><span class="line">  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== &apos;function&apos;) &#123; </span><br><span class="line">    return [];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class="line">    // 因为我们不想改变原始数组。</span><br><span class="line">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      result.push(mapCallback(arr[i], i, arr)); </span><br><span class="line">      // 将 mapCallback 返回的结果 push 到 result 数组中</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手动实现Array-prototype-filter方法"><a href="#手动实现Array-prototype-filter方法" class="headerlink" title="手动实现Array.prototype.filter方法"></a>手动实现Array.prototype.filter方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</span><br><span class="line">function filter(arr, filterCallback) &#123;</span><br><span class="line">  // 首先，检查传递的参数是否正确。</span><br><span class="line">  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== &apos;function&apos;) </span><br><span class="line">  &#123;</span><br><span class="line">    return [];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">     // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class="line">     // 因为我们不想改变原始数组。</span><br><span class="line">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      // 检查 filterCallback 的返回值是否是真值</span><br><span class="line">      if (filterCallback(arr[i], i, arr)) &#123; </span><br><span class="line">      // 如果条件为真，则将数组元素 push 到 result 中</span><br><span class="line">        result.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result; // return the result array</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手动实现Array-prototype-reduce方法"><a href="#手动实现Array-prototype-reduce方法" class="headerlink" title="手动实现Array.prototype.reduce方法"></a>手动实现Array.prototype.reduce方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。</span><br><span class="line"></span><br><span class="line">function reduce(arr, reduceCallback, initialValue) &#123;</span><br><span class="line">  // 首先，检查传递的参数是否正确。</span><br><span class="line">  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== &apos;function&apos;) </span><br><span class="line">  &#123;</span><br><span class="line">    return [];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue</span><br><span class="line">    let hasInitialValue = initialValue !== undefined;</span><br><span class="line">    let value = hasInitialValue ? initialValue : arr[0];</span><br><span class="line">   、</span><br><span class="line"></span><br><span class="line">    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始</span><br><span class="line">    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      value = reduceCallback(value, arr[i], i, arr); </span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="js的深浅拷贝"><a href="#js的深浅拷贝" class="headerlink" title="js的深浅拷贝"></a>js的深浅拷贝</h3><blockquote>
<p>JavaScript的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础版的。所以在写这条之前我拜读了收藏夹里各路大佬写的博文。具体可以看下面我贴的链接，这里只做简单的总结。</p>
<ul>
<li>浅拷贝： 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li>
<li>深拷贝： 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。<br>浅拷贝的实现方式：</li>
<li>Object.assign() 方法： 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li>
<li>Array.prototype.slice()：slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</li>
<li>拓展运算符…：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    name: &quot;Jake&quot;,</span><br><span class="line">    flag: &#123;</span><br><span class="line">        title: &quot;better day by day&quot;,</span><br><span class="line">        time: &quot;2020-05-31&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = &#123;...a&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<p>深拷贝的实现方式：</p>
<ul>
<li>乞丐版： JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）</li>
<li>基础版（面试够用）： 浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function cloneDeep(target,map = new WeakMap()) &#123;</span><br><span class="line">  if(typeOf taret ===&apos;object&apos;)&#123;</span><br><span class="line">     let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">      </span><br><span class="line">     if(map.get(target)) &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">     map.set(target, cloneTarget);</span><br><span class="line">     for(const key in target)&#123;</span><br><span class="line">        cloneTarget[key] = cloneDeep(target[key], map);</span><br><span class="line">     &#125;</span><br><span class="line">     return cloneTarget</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">       return target</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>终极版：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mapTag = &apos;[object Map]&apos;;</span><br><span class="line">const setTag = &apos;[object Set]&apos;;</span><br><span class="line">const arrayTag = &apos;[object Array]&apos;;</span><br><span class="line">const objectTag = &apos;[object Object]&apos;;</span><br><span class="line">const argsTag = &apos;[object Arguments]&apos;;</span><br><span class="line"></span><br><span class="line">const boolTag = &apos;[object Boolean]&apos;;</span><br><span class="line">const dateTag = &apos;[object Date]&apos;;</span><br><span class="line">const numberTag = &apos;[object Number]&apos;;</span><br><span class="line">const stringTag = &apos;[object String]&apos;;</span><br><span class="line">const symbolTag = &apos;[object Symbol]&apos;;</span><br><span class="line">const errorTag = &apos;[object Error]&apos;;</span><br><span class="line">const regexpTag = &apos;[object RegExp]&apos;;</span><br><span class="line">const funcTag = &apos;[object Function]&apos;;</span><br><span class="line"></span><br><span class="line">const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function forEach(array, iteratee) &#123;</span><br><span class="line">    let index = -1;</span><br><span class="line">    const length = array.length;</span><br><span class="line">    while (++index &lt; length) &#123;</span><br><span class="line">        iteratee(array[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isObject(target) &#123;</span><br><span class="line">    const type = typeof target;</span><br><span class="line">    return target !== null &amp;&amp; (type === &apos;object&apos; || type === &apos;function&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getType(target) &#123;</span><br><span class="line">    return Object.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getInit(target) &#123;</span><br><span class="line">    const Ctor = target.constructor;</span><br><span class="line">    return new Ctor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneSymbol(targe) &#123;</span><br><span class="line">    return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneReg(targe) &#123;</span><br><span class="line">    const reFlags = /\w*$/;</span><br><span class="line">    const result = new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class="line">    result.lastIndex = targe.lastIndex;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneFunction(func) &#123;</span><br><span class="line">    const bodyReg = /(?&lt;=&#123;)(.|\n)+(?=&#125;)/m;</span><br><span class="line">    const paramReg = /(?&lt;=\().+(?=\)\s+&#123;)/;</span><br><span class="line">    const funcString = func.toString();</span><br><span class="line">    if (func.prototype) &#123;</span><br><span class="line">        const param = paramReg.exec(funcString);</span><br><span class="line">        const body = bodyReg.exec(funcString);</span><br><span class="line">        if (body) &#123;</span><br><span class="line">            if (param) &#123;</span><br><span class="line">                const paramArr = param[0].split(&apos;,&apos;);</span><br><span class="line">                return new Function(...paramArr, body[0]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return new Function(body[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return eval(funcString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneOtherType(targe, type) &#123;</span><br><span class="line">    const Ctor = targe.constructor;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case boolTag:</span><br><span class="line">        case numberTag:</span><br><span class="line">        case stringTag:</span><br><span class="line">        case errorTag:</span><br><span class="line">        case dateTag:</span><br><span class="line">            return new Ctor(targe);</span><br><span class="line">        case regexpTag:</span><br><span class="line">            return cloneReg(targe);</span><br><span class="line">        case symbolTag:</span><br><span class="line">            return cloneSymbol(targe);</span><br><span class="line">        case funcTag:</span><br><span class="line">            return cloneFunction(targe);</span><br><span class="line">        default:</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clone(target, map = new WeakMap()) &#123;</span><br><span class="line"></span><br><span class="line">    // 克隆原始类型</span><br><span class="line">    if (!isObject(target)) &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化</span><br><span class="line">    const type = getType(target);</span><br><span class="line">    let cloneTarget;</span><br><span class="line">    if (deepTag.includes(type)) &#123;</span><br><span class="line">        cloneTarget = getInit(target, type);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return cloneOtherType(target, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 防止循环引用</span><br><span class="line">    if (map.get(target)) &#123;</span><br><span class="line">        return map.get(target);</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">    // 克隆set</span><br><span class="line">    if (type === setTag) &#123;</span><br><span class="line">        target.forEach(value =&gt; &#123;</span><br><span class="line">            cloneTarget.add(clone(value, map));</span><br><span class="line">        &#125;);</span><br><span class="line">        return cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 克隆map</span><br><span class="line">    if (type === mapTag) &#123;</span><br><span class="line">        target.forEach((value, key) =&gt; &#123;</span><br><span class="line">            cloneTarget.set(key, clone(value, map));</span><br><span class="line">        &#125;);</span><br><span class="line">        return cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 克隆对象和数组</span><br><span class="line">    const keys = type === arrayTag ? undefined : Object.keys(target);</span><br><span class="line">    forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">        if (keys) &#123;</span><br><span class="line">            key = value;</span><br><span class="line">        &#125;</span><br><span class="line">        cloneTarget[key] = clone(target[key], map);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return cloneTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    clone</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="手写call、apply及bind函数"><a href="#手写call、apply及bind函数" class="headerlink" title="手写call、apply及bind函数"></a>手写call、apply及bind函数</h3><p>call 函数的实现步骤：</p>
<ul>
<li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>3.处理传入的参数，截取第一个参数后的所有参数。</li>
<li>4.将函数作为上下文对象的一个属性。</li>
<li>5.使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>6.删除刚才新增的属性。</li>
<li>7.返回结果。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// call函数实现</span><br><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">  // 判断调用对象</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    console.error(&quot;type error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取参数</span><br><span class="line">  let args = [...arguments].slice(1),</span><br><span class="line">    result = null;</span><br><span class="line"></span><br><span class="line">  // 判断 context 是否传入，如果未传入则设置为 window</span><br><span class="line">  context = context || window;</span><br><span class="line"></span><br><span class="line">  // 将调用函数设为对象的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  // 调用函数</span><br><span class="line">  result = context.fn(...args);</span><br><span class="line"></span><br><span class="line">  // 将属性删除</span><br><span class="line">  delete context.fn;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>apply 函数的实现步骤：</p>
<ul>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>判断参数值是否传入</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性</li>
<li>返回结果<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// apply 函数实现</span><br><span class="line"></span><br><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">  // 判断调用对象是否为函数</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let result = null;</span><br><span class="line"></span><br><span class="line">  // 判断 context 是否存在，如果未传入则为 window</span><br><span class="line">  context = context || window;</span><br><span class="line"></span><br><span class="line">  // 将函数设为对象的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  // 调用方法</span><br><span class="line">  if (arguments[1]) &#123; </span><br><span class="line">    result = context.fn(...arguments[1]);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将属性删除</span><br><span class="line">  delete context.fn;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>bind 函数的实现步骤：</p>
<ul>
<li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>2.保存当前函数的引用，获取其余传入参数值。</li>
<li>3.创建一个函数返回</li>
<li>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bind 函数实现</span><br><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  // 判断调用对象是否为函数</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取参数</span><br><span class="line">  var args = [...arguments].slice(1),</span><br><span class="line">    fn = this;</span><br><span class="line"></span><br><span class="line">  return function Fn() &#123;</span><br><span class="line">    // 根据调用方式，传入不同绑定值</span><br><span class="line">    return fn.apply(</span><br><span class="line">      this instanceof Fn ? this : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span><br><span class="line"></span><br><span class="line">function curry(fn, args) &#123;</span><br><span class="line">  // 获取函数需要的参数长度</span><br><span class="line">  let length = fn.length;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">    let subArgs = args.slice(0);</span><br><span class="line"></span><br><span class="line">    // 拼接得到现有的所有参数</span><br><span class="line">    for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">      subArgs.push(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断参数的长度是否已经满足函数所需参数的长度</span><br><span class="line">    if (subArgs.length &gt;= length) &#123;</span><br><span class="line">      // 如果满足，执行函数</span><br><span class="line">      return fn.apply(this, subArgs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 如果不满足，递归返回科里化的函数，等待参数的传入</span><br><span class="line">      return curry.call(this, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// es6 实现</span><br><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="js模拟new操作符的实现"><a href="#js模拟new操作符的实现" class="headerlink" title="js模拟new操作符的实现"></a>js模拟new操作符的实现</h3><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。new 关键字会进行如下的操作：</p>
<ol>
<li>创建一个空的简单JavaScript对象（即{}）；</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>
<li>将步骤1新创建的对象作为this的上下文 ；</li>
<li>如果该函数没有返回对象，则返回this。<br>接下来我们看实现：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Dog(name, color, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.color = color;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype=&#123;</span><br><span class="line">  getName: function() &#123;</span><br><span class="line">    return this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dog = new Dog(&apos;大黄&apos;, &apos;yellow&apos;, 3)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的代码相信不用解释，大家都懂。我们来看最后一行带new关键字的代码，按照上述的1,2,3,4步来解析new背后的操作。</p>
<p>第一步：创建一个简单空对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步：链接该对象到另一个对象（原型链）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 设置原型链</span><br><span class="line">obj.__proto__ = Dog.prototype</span><br></pre></td></tr></table></figure></p>
<p>第三步：将步骤1新创建的对象作为 this 的上下文<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// this指向obj对象</span><br><span class="line">Dog.apply(obj, [&apos;大黄&apos;, &apos;yellow&apos;, 3])</span><br></pre></td></tr></table></figure></p>
<p>第四步：如果该函数没有返回对象，则返回this<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 因为 Dog() 没有返回值，所以返回obj</span><br><span class="line">var dog = obj</span><br><span class="line">dog.getName() // &apos;大黄&apos;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是如果 Dog() 有 return 则返回 return的值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rtnObj = &#123;&#125;</span><br><span class="line">function Dog(name, color, age) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  //返回一个对象</span><br><span class="line">  return rtnObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dog = new Dog(&apos;大黄&apos;, &apos;yellow&apos;, 3)</span><br><span class="line">console.log(dog === rtnObj) // true</span><br></pre></td></tr></table></figure></p>
<p>接下来我们将以上步骤封装成一个对象实例化方法，即模拟new的操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function objectFactory()&#123;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">    //取得该方法的第一个参数(并删除第一个参数)，该参数是构造函数</span><br><span class="line">    var Constructor = [].shift.apply(arguments);</span><br><span class="line">    //将新对象的内部属性__proto__指向构造函数的原型，这样新对象就可以访问原型中的属性和方法</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    //取得构造函数的返回值</span><br><span class="line">    var ret = Constructor.apply(obj, arguments);</span><br><span class="line">    //如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象</span><br><span class="line">    return typeof ret === &quot;object&quot; ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="什么是回调函数？回调函数有什么缺点"><a href="#什么是回调函数？回调函数有什么缺点" class="headerlink" title="什么是回调函数？回调函数有什么缺点"></a>什么是回调函数？回调函数有什么缺点</h3><p>回调函数是一段可执行的代码段，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。<br>在JavaScript中函数也是对象的一种，同样对象可以作为参数传递给函数，因此函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。</p>
<h3 id="Promise是什么，可以手写实现一下吗？"><a href="#Promise是什么，可以手写实现一下吗？" class="headerlink" title="Promise是什么，可以手写实现一下吗？"></a>Promise是什么，可以手写实现一下吗？</h3><p>Promise，翻译过来是承诺，承诺它过一段时间会给你一个结果。从编程讲Promise 是异步编程的一种解决方案。下面是Promise在MDN的相关说明：<br>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。<br>一个 Promise有以下几种状态:</p>
<ul>
<li>pending: 初始状态，既不是成功，也不是失败状态。</li>
<li>fulfilled: 意味着操作成功完成。</li>
<li>rejected: 意味着操作失败。<br>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 fulfilled/rejected 后，就不能再次改变。<br>可能光看概念大家不理解Promise，我们举个简单的栗子；<br>假如我有个女朋友，下周一是她生日，我答应她生日给她一个惊喜，那么从现在开始这个承诺就进入等待状态，等待下周一的到来，然后状态改变。如果下周一我如约给了女朋友惊喜，那么这个承诺的状态就会由pending切换为fulfilled，表示承诺成功兑现，一旦是这个结果了，就不会再有其他结果，即状态不会在发生改变；反之如果当天我因为工作太忙加班，把这事给忘了，说好的惊喜没有兑现，状态就会由pending切换为rejected，时间不可倒流，所以状态也不能再发生变化。<br>上一条我们说过Promise可以解决回调地狱的问题，没错，pending 状态的 Promise 对象会触发 fulfilled/rejected 状态，一旦状态改变，Promise 对象的 then 方法就会被调用；否则就会触发 catch。我们将上一条回调地狱的代码改写一下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve，reject) =&gt; &#123;</span><br><span class="line">     setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(1)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;,1000)</span><br><span class="line">        </span><br><span class="line">&#125;).then((res) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(2)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">&#125;).then((res) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(3)</span><br><span class="line">        &#125;,3000)</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其实Promise也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。<br>手写版本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myPromise(constructor)&#123;</span><br><span class="line">    let self=this;</span><br><span class="line">    self.status=&quot;pending&quot; //定义状态改变前的初始状态</span><br><span class="line">    self.value=undefined;//定义状态为resolved的时候的状态</span><br><span class="line">    self.reason=undefined;//定义状态为rejected的时候的状态</span><br><span class="line">    function resolve(value)&#123;</span><br><span class="line">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class="line">          self.value=value;</span><br><span class="line">          self.status=&quot;resolved&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason)&#123;</span><br><span class="line">        //两个===&quot;pending&quot;，保证了状态的改变是不可逆的</span><br><span class="line">       if(self.status===&quot;pending&quot;)&#123;</span><br><span class="line">          self.reason=reason;</span><br><span class="line">          self.status=&quot;rejected&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //捕获构造异常</span><br><span class="line">    try&#123;</span><br><span class="line">       constructor(resolve,reject);</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">       reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 定义链式调用的then方法</span><br><span class="line">myPromise.prototype.then=function(onFullfilled,onRejected)&#123;</span><br><span class="line">   let self=this;</span><br><span class="line">   switch(self.status)&#123;</span><br><span class="line">      case &quot;resolved&quot;:</span><br><span class="line">        onFullfilled(self.value);</span><br><span class="line">        break;</span><br><span class="line">      case &quot;rejected&quot;:</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">        break;</span><br><span class="line">      default:       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Iterator是什么，有什么作用？"><a href="#Iterator是什么，有什么作用？" class="headerlink" title="Iterator是什么，有什么作用？"></a>Iterator是什么，有什么作用？</h3><p>Iterator是理解第61条的先决知识<br>Iterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">    [Symbol.iterator]:function()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>[Symbol.iterator] 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历。<br>迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 next 方法，改变指针的指向，让其指向下一条数据<br>每一次的 next 都会返回一个对象，该对象有两个属性</p>
<ul>
<li>value 代表想要获取的数据</li>
<li>done 布尔值，false表示当前指针指向的数据有值，true表示遍历已经结束<br>Iterator 的作用有三个：</li>
</ul>
<ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>使得数据结构的成员能够按某种次序排列；</li>
<li>ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。<br>遍历过程：</li>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。<br>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [&#123;num:1&#125;,2,3]</span><br><span class="line">let it = arr[Symbol.iterator]() // 获取数组中的迭代器</span><br><span class="line">console.log(it.next())  // &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span><br><span class="line">console.log(it.next())  // &#123; value: 2, done: false &#125;</span><br><span class="line">console.log(it.next())  // &#123; value: 3, done: false &#125;</span><br><span class="line">console.log(it.next())  // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Generator函数是什么，有什么作用？"><a href="#Generator函数是什么，有什么作用？" class="headerlink" title="Generator函数是什么，有什么作用？"></a>Generator函数是什么，有什么作用？</h3><h3 id="什么是-async-await及其如何工作-有什么优缺点？"><a href="#什么是-async-await及其如何工作-有什么优缺点？" class="headerlink" title="什么是 async/await及其如何工作,有什么优缺点？"></a>什么是 async/await及其如何工作,有什么优缺点？</h3><h3 id="instanceof的原理是什么，如何实现"><a href="#instanceof的原理是什么，如何实现" class="headerlink" title="instanceof的原理是什么，如何实现"></a>instanceof的原理是什么，如何实现</h3><h3 id="js的节流与防抖"><a href="#js的节流与防抖" class="headerlink" title="js的节流与防抖"></a>js的节流与防抖</h3><h3 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h3><h3 id="9种前端常见的设计模式"><a href="#9种前端常见的设计模式" class="headerlink" title="9种前端常见的设计模式"></a>9种前端常见的设计模式</h3>
    </article>
    <!-- license  -->
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2020/07/13/BFC理解原理/" title= "BFC理解原理">
                    <div class="prevTitle">BFC理解原理</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:1309609944@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/highzq" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍一下js的数据类型有哪些-值是如何存储的"><span class="toc-number">1.</span> <span class="toc-text">介绍一下js的数据类型有哪些,值是如何存储的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp-amp-、-和-运算符分别能做什么"><span class="toc-number">2.</span> <span class="toc-text">&amp;&amp; 、 ||和!! 运算符分别能做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS的数据类型的转换"><span class="toc-number">3.</span> <span class="toc-text">JS的数据类型的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS中数据类型的判断（-typeof，instanceof，constructor，Object-prototype-toString-call"><span class="toc-number">4.</span> <span class="toc-text">JS中数据类型的判断（ typeof，instanceof，constructor，Object.prototype.toString.call()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-JS-有哪些内置对象？"><span class="toc-number">5.</span> <span class="toc-text">介绍 JS 有哪些内置对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined-与-undeclared-的区别？"><span class="toc-number">6.</span> <span class="toc-text">undefined 与 undeclared 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-和-undefined-的区别？"><span class="toc-number">7.</span> <span class="toc-text">null 和 undefined 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和-的valueOf和toString的结果是什么？"><span class="toc-number">8.</span> <span class="toc-text">{}和[]的valueOf和toString的结果是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Javascript-的作用域和作用域链？"><span class="toc-number">9.</span> <span class="toc-text">Javascript 的作用域和作用域链？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript-创建对象的几种方式？"><span class="toc-number">10.</span> <span class="toc-text">javascript 创建对象的几种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-继承的几种实现方式？"><span class="toc-number">11.</span> <span class="toc-text">JavaScript 继承的几种实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄生式组合继承的实现？"><span class="toc-number">12.</span> <span class="toc-text">寄生式组合继承的实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈你对this、call、apply和bind的理解"><span class="toc-number">13.</span> <span class="toc-text">谈谈你对this、call、apply和bind的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-原型，原型链？-有什么特点？"><span class="toc-number">14.</span> <span class="toc-text">JavaScript 原型，原型链？ 有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-获取原型的方法？"><span class="toc-number">15.</span> <span class="toc-text">js 获取原型的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是闭包，为什么要用它？"><span class="toc-number">16.</span> <span class="toc-text">什么是闭包，为什么要用它？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-DOM-和-BOM？"><span class="toc-number">17.</span> <span class="toc-text">什么是 DOM 和 BOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种事件模型是什么？"><span class="toc-number">18.</span> <span class="toc-text">三种事件模型是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件委托是什么？"><span class="toc-number">19.</span> <span class="toc-text">事件委托是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是事件传播"><span class="toc-number">20.</span> <span class="toc-text">什么是事件传播?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是事件捕获？"><span class="toc-number">21.</span> <span class="toc-text">什么是事件捕获？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是事件冒泡？"><span class="toc-number">22.</span> <span class="toc-text">什么是事件冒泡？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><span class="toc-number">23.</span> <span class="toc-text">DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js数组和对象有哪些原生方法-列举一下"><span class="toc-number">24.</span> <span class="toc-text">js数组和对象有哪些原生方法,列举一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的正则表达式"><span class="toc-number">25.</span> <span class="toc-text">常用的正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ajax-是什么-如何创建一个-Ajax？"><span class="toc-number">26.</span> <span class="toc-text">Ajax 是什么? 如何创建一个 Ajax？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-延迟加载的方式有哪些？"><span class="toc-number">27.</span> <span class="toc-text">js 延迟加载的方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈你对模块化开发的理解？"><span class="toc-number">28.</span> <span class="toc-text">谈谈你对模块化开发的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-的几种模块规范？"><span class="toc-number">29.</span> <span class="toc-text">js 的几种模块规范？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMD和CMD-规范的区别？"><span class="toc-number">30.</span> <span class="toc-text">AMD和CMD 规范的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><span class="toc-number">31.</span> <span class="toc-text">ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#requireJS的核心原理是什么？"><span class="toc-number">32.</span> <span class="toc-text">requireJS的核心原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈JS的运行机制"><span class="toc-number">33.</span> <span class="toc-text">谈谈JS的运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arguments-的对象是什么？"><span class="toc-number">34.</span> <span class="toc-text">arguments 的对象是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么在调用这个函数时，代码中的b会变成一个全局变量"><span class="toc-number">35.</span> <span class="toc-text">为什么在调用这个函数时，代码中的b会变成一个全局变量?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单介绍一下V8引擎的垃圾回收机制"><span class="toc-number">36.</span> <span class="toc-text">简单介绍一下V8引擎的垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哪些操作会造成内存泄漏？"><span class="toc-number">37.</span> <span class="toc-text">哪些操作会造成内存泄漏？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECMAScript-是什么？"><span class="toc-number">38.</span> <span class="toc-text">ECMAScript 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECMAScript-2015（ES6）有哪些新特性？"><span class="toc-number">39.</span> <span class="toc-text">ECMAScript 2015（ES6）有哪些新特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#var-let和const的区别是什么？"><span class="toc-number">40.</span> <span class="toc-text">var,let和const的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是箭头函数？"><span class="toc-number">41.</span> <span class="toc-text">什么是箭头函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是类？"><span class="toc-number">42.</span> <span class="toc-text">什么是类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是模板字符串？"><span class="toc-number">43.</span> <span class="toc-text">什么是模板字符串？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是对象解构？"><span class="toc-number">44.</span> <span class="toc-text">什么是对象解构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Set对象，它是如何工作的？"><span class="toc-number">45.</span> <span class="toc-text">什么是Set对象，它是如何工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Proxy？"><span class="toc-number">46.</span> <span class="toc-text">什么是Proxy？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写一个通用的事件侦听器函数？"><span class="toc-number">47.</span> <span class="toc-text">写一个通用的事件侦听器函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是函数式编程-JavaScript的哪些特性使其成为函数式语言的候选语言？"><span class="toc-number">48.</span> <span class="toc-text">什么是函数式编程? JavaScript的哪些特性使其成为函数式语言的候选语言？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是高阶函数？"><span class="toc-number">49.</span> <span class="toc-text">什么是高阶函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么函数被称为一等公民？"><span class="toc-number">50.</span> <span class="toc-text">为什么函数被称为一等公民？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手动实现Array-prototype-map-方法"><span class="toc-number">51.</span> <span class="toc-text">手动实现Array.prototype.map 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手动实现Array-prototype-filter方法"><span class="toc-number">52.</span> <span class="toc-text">手动实现Array.prototype.filter方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手动实现Array-prototype-reduce方法"><span class="toc-number">53.</span> <span class="toc-text">手动实现Array.prototype.reduce方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js的深浅拷贝"><span class="toc-number">54.</span> <span class="toc-text">js的深浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手写call、apply及bind函数"><span class="toc-number">55.</span> <span class="toc-text">手写call、apply及bind函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数柯里化的实现"><span class="toc-number">56.</span> <span class="toc-text">函数柯里化的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js模拟new操作符的实现"><span class="toc-number">57.</span> <span class="toc-text">js模拟new操作符的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是回调函数？回调函数有什么缺点"><span class="toc-number">58.</span> <span class="toc-text">什么是回调函数？回调函数有什么缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise是什么，可以手写实现一下吗？"><span class="toc-number">59.</span> <span class="toc-text">Promise是什么，可以手写实现一下吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator是什么，有什么作用？"><span class="toc-number">60.</span> <span class="toc-text">Iterator是什么，有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generator函数是什么，有什么作用？"><span class="toc-number">61.</span> <span class="toc-text">Generator函数是什么，有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-async-await及其如何工作-有什么优缺点？"><span class="toc-number">62.</span> <span class="toc-text">什么是 async/await及其如何工作,有什么优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof的原理是什么，如何实现"><span class="toc-number">63.</span> <span class="toc-text">instanceof的原理是什么，如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js的节流与防抖"><span class="toc-number">64.</span> <span class="toc-text">js的节流与防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是设计模式？"><span class="toc-number">65.</span> <span class="toc-text">什么是设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9种前端常见的设计模式"><span class="toc-number">66.</span> <span class="toc-text">9种前端常见的设计模式</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 6
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/13</span><a class="archive-post-title" href= "/2020/07/13/问题整理/" >问题整理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/13</span><a class="archive-post-title" href= "/2020/07/13/BFC理解原理/" >BFC理解原理</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/29</span><a class="archive-post-title" href= "/2019/03/29/react-Context-上下文方法使用/" >react Context(上下文方法使用)</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2018/07/25/forEach兼容写法/" >forEach兼容写法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2018/07/25/让h5页面强制横屏/" >让h5页面强制横屏</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/13</span><a class="archive-post-title" href= "/2018/07/13/使用hexo搭建博客时遇到的问题/" >使用hexo搭建博客时遇到的问题</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="HTML"><span class="iconfont-archer">&#xe606;</span>HTML</span>
    
        <span class="sidebar-tag-name" data-tags="心得"><span class="iconfont-archer">&#xe606;</span>心得</span>
    
        <span class="sidebar-tag-name" data-tags="文章"><span class="iconfont-archer">&#xe606;</span>文章</span>
    
        <span class="sidebar-tag-name" data-tags="javaScript"><span class="iconfont-archer">&#xe606;</span>javaScript</span>
    
        <span class="sidebar-tag-name" data-tags="技巧"><span class="iconfont-archer">&#xe606;</span>技巧</span>
    
        <span class="sidebar-tag-name" data-tags="react"><span class="iconfont-archer">&#xe606;</span>react</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="技术"><span class="iconfont-archer">&#xe60a;</span>技术</span>
    
        <span class="sidebar-category-name" data-categories="记录"><span class="iconfont-archer">&#xe60a;</span>记录</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Gao"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


